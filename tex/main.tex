%% 
%% ACS project dissertation template. 
%% 
%% Currently designed for printing two-sided, but if you prefer to 
%% print single-sided just remove ",twoside,openright" from the 
%% \documentclass[] line below. 
%%
%%
%%   SMH, May 2010. 

\documentclass[a4paper,9pt]{report}
%\documentclass[a4paper,12pt,twoside,openright]{report}


%%
%% EDIT THE BELOW TO CUSTOMIZE
%%

\def\authorname{Khalid Aleem\xspace}
\def\authorcollege{Trinity College\xspace}
\def\authoremail{ka476@cam.ac.uk}
\def\dissertationtitle{A Risc-V based co-processor peripheral to accelerate CNN inference.}
\def\wordcount{14,235}


%\usepackage[dvips]{epsfig,graphics} 
\usepackage{epsfig,graphicx,verbatim,parskip,tabularx,setspace,xspace}

\usepackage{booktabs}
\usepackage{amsmath,amssymb}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}



%% START OF DOCUMENT
\begin{document}


%% FRONTMATTER (TITLE PAGE, DECLARATION, ABSTRACT, ETC) 
\pagestyle{empty}
\singlespacing
\input{titlepage}
\onehalfspacing
\input{declaration}
\singlespacing
\input{abstract}

\pagenumbering{roman}
\setcounter{page}{0}
\pagestyle{plain}
\tableofcontents
\listoffigures
\listoftables

\onehalfspacing


\chapter{Introduction}
\pagenumbering{arabic} 
\setcounter{page}{1} 

% Work on Story
% Embedded Devices
% RiscV - ^ - 

\chapter{Background} 
% Risc-V
% Verilator
% Xilinx Vivado
% Quartus Qsys


\chapter{Related Work} 
% BlueVec
% Rocket RoCC
% Google TPU?
% Nvidia GPUs?!

\chapter{Design and Implementation}
% Design decisions

% Test bench --- functional
% Floating point unit (mstatus csr)
% RV32imafc - bare metal ELF
% Linker file, bare metal
% Spike, proxy kernel
% Bare Metal LibC - RiscV
% Heap memory!

% Cost of movement...

% Matrix multiplication
% Naive implementation
% Unit duplication NAIVE
% Unit duplication - scheduling
% Copy cost

% endianness & packing

% ZipReduceUnitServer - improvements + bench
% Unit duplication - special memory & wire connections!
%


% RegFile vs Vector#(Reg#()) vs BRAM


\section{SoC Design}
% NOTE: image of SoC
% CPU/AXI4 e.t.c.

\subsection{AXI4 Protocol}
% TODO: Background info/filler and origin
\texttt{wstrb}
% TODO: How is memory read/written from

The AXI4 protocol comes with the disadvantage of being able write a maximum of 4
bytes per clock cycle.
% TODO: To what extent does this 

\section{Fixing Piccolo}
\subsection{Floating Point Unit}
\subsubsection{Fixing FPU typeerrors}
The latest commit of the Piccolo processor, (), has a type error in the floating
point unit. 

We must enter, FPU.bsv and FBox\_Core.bsv and prefix the RoundMode type with FloatingPoint::RoundMode.

% NOTE: Compile log
% compiling Piccolo/src_Core/CPU/FPU.bsv
% Warning: Unknown position: (S0080)
% 1 warnings were suppressed.
% Error: "Piccolo/src_Core/CPU/FPU.bsv", line 52, column 30: (T0080)
% Type error at the use of the following function:
% mkFloatingPointDivider

% The expected return type of the function:
% g__#(ClientServer::Server#(Tuple3#(FPU::FSingle, FPU::FSingle, ISA_Decls::RoundMode), FPU::FpuR))

% The return type according to the use:
% c__#(ClientServer::Server#(Tuple3#(FloatingPoint::FloatingPoint#(d__, e__),
% FloatingPoint::FloatingPoint#(d__, e__),
% FloatingPoint::RoundMode),
% Tuple2#(FloatingPoint::FloatingPoint#(d__, e__), FloatingPoint::Exception)))


\subsubsection{mstatus CSR}
Once the FPU is successfully compiled, and the processor is compiled with
floating point support, the processor will trap when a floating point
instruction is executed.

% NOTE: Clean code
\texttt{float a = 1.0f;} \\
\texttt{80002276: lui a5, 0x80001}
\texttt{8000227a: flw fa5,424(a5)}
\texttt{8000227e: fsw fa5,-28(s0)}
\texttt{Trap\_Info { epc: 'h8000227a, exc\_code: 'h2, tval: 'h1a87a787 }} \\
\texttt{Trap Exc: ILLEGAL\_INSTRUCTION} \\

% TODO: Citation
This makes sense as per the Risc-V specification, Chapter 3, Section 1.11.
The fs bit on the mstatus CSR must be set in order for floating-point
instructions to be enabled. We can see how this is done in bare-metal C, by
looking at the source code for the Spike Risc-V proxy kernel.

% https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf

\subsection{Test Accelerator Control}
When constructing an accelerator, it is important to work constructively from a minimum
functioning unit.

We make use of the test bench provided by Piccolo as a basis for our
simulations.

We create a simple peripheral, with a region of memory that we can write 4-byte
integers into. When a special execution bit is set, we set a special accelerator
busy bit and unset the execution bit. In a single cycle, as part of the
accelerator, if the busy bit is set, we double the array and unset the busy bit.
This allows the firmware to write an array into the accelerator memory, set the
execution control bit, and stall until the busy bit is unset.

% NOTE: Firmware C code for accelerator
% NOTE: Console log
% 0: 0
% 1: 1
% 2: 2
% 3: 3
% Set Control Bit..
% Stalling..
% Stall complete!
% 0: 0
% 1: 2
% 2: 4
% 3: 6


\subsection{AXI4 Alignment/Padding}

This code results in the cpu trapping:
\texttt{*((uint32\_t\*)0xC0001002) = 1337;}

\texttt{Trap\_Info { epc: 'h800022d6, exc\_code: 'h6, tval: 'hc0001002 }}
The exception/trap code corresponds to:
TRAP EXC: STORE\_AMO\_ADDR\_MISALIGNED

% TODO: Introduce the need for struct padding/packing
This is of particular importance to consider when we issue a command to the
accelerator. In order to ensure 

\section{Matrix Reduction}
\subsection{Overview}

Mathematically, the result of a matrix multiplication may be expressed
accordingly:
\begin{align*}
  C &= AB \\
  C_{ij} &= \sum_k A_{ik}B_{kj}
\end{align*}

Matrix multiplication may be expressed in a programmatic form accordingly:
\texttt{C[i][j] = sum zipWith (op*) (row A i) (col B j)}

This can be implemented in two possible ways.
We could approach things purely in hardware, issue a command containing the
locations and dimensions of each of the matrices, and expect the hardware to
write an output matrix to our memory.
Alternatively, we may take advantage of the existence of firmware. It is
possible that 

Our peripheral contains a RegFile of internal memory which is memory mapped to
the CPU via an AXI4 bus slave interface.

\begin{tabular}{lll}
  \toprule
  Offset Address Range & Size & Purpose \\
  \midrule
  \texttt{0x0000-0x0020} & 32 Bytes & Status \\
  \texttt{0x0020-0x0040} & 32 Bytes & Control \\
  \texttt{0x0040-0x1000} & $\approx$ 4 KB & Memory \\
  \bottomrule
\end{tabular}

\subsubsection{Status}
The first byte of our status memory is to monitor, and control execution from
the accelerator.
We write our control command/instruction to the control memory bank. We then set out
execute status bit, and the accelerator should run the appropriate command.

\subsubsection{Control}

\subsubsection{Memory}


\subsection{Unit Design} 
BSV contains a FloatingPoint library, which extends the Server module.
We can put a request, and after some number of clock cycles, get a response.

% Unit Design
% Unit: Simple: Pipelined Multiply + Sequential Add
% Unit: FusedMultiplyAccumulate
% Unit: Speedup - Tree addition (pipelined addition)


% Unit: Memory Parallelism
% Unit: Memory Banking:
% https://tomverbeure.github.io/2019/08/03/Multiport-Memories.html  

\subsection{Unit Speed-up}
\subsection{Unit Parallelism - Naive}

% TODO: Jesus...
\subsection{Memory Parallelism}

% What is a Regfile, What is BlockRam? What is SRAM?
We observe that a RegFile, has a maximum of 5 read ports, and 1 write port.
Typically, BRAM, has 2 read ports, and 1 write port.

% Error: "MultiPortBRAM.bsv", line 18, column 37: (G0002)
% `pmem_mem_0.sub' needs more than 5 ports for the following uses:
% `pmem_mem_0.sub a__h30554' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h31995' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32028' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32061' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32094' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32127' at "MultiPortBRAM.bsv", line 18, column 37

\subsection{Memory Striping/Banking}


\section{Bottlenecks}

\chapter{Evaluation} 
\section{Methodology}

\subsection{Fused Multiply Accumulate}
% Cannot exploit pipelined nature of unit.
% Faster than individual FP multiply, then add. 10 cycles vs 14 cycles.

%  10: FSM Start
%  20: Init
%  40: PUT: 00000000 40800000 40800000
%  40: STATE_LOCK
% 140: 0: MulAcc Result: 41800000
% 140: STATE_READY
% 150: PUT: 41800000 40800000 40800000
% 150: STATE_LOCK
% 250: 1: MulAcc Result: 42000000
% 250: STATE_READY
% 260: PUT: 42000000 40800000 40800000
% 260: STATE_LOCK
% 360: 2: MulAcc Result: 42400000
% 360: STATE_READY
% 370: PUT: 42400000 40800000 40800000
% 370: STATE_LOCK
% 470: 3: MulAcc Result: 42800000
% 470: STATE_COMPLETE
% 480: Output: 42800000

\begin{align*}
  T_{Naive}(N) &= 11+N + 4N \\
  &= 15 + 5N \\
  T_{FMA}(N) &= (10+1)N \\
             &= 11N \\
  T_{TADD}(N) &= max(10+N, 11+2\frac{N}{2} + \frac{N}{4} + ... + 16) \\
             &= 2N+27 
\end{align*}


\subsection{Benchmarking \& Counting cycles}
From the Risc-V specification, we take a look at the mcycles and minstret
registers.
% TODO: Example + study (Evaluation)

\subsection{MNIST Neural Network: Dense Layers}

\chapter{Summary and Conclusions} 


\appendix
\singlespacing

\bibliographystyle{unsrt} 
%\bibliography{dissertation} 

\end{document}
