%% 
%% ACS project dissertation template. 
%% 
%% Currently designed for printing two-sided, but if you prefer to 
%% print single-sided just remove ",twoside,openright" from the 
%% \documentclass[] line below. 
%%
%%
%%   SMH, May 2010. 

\documentclass[a4paper,9pt]{report}
%\documentclass[a4paper,12pt,twoside,openright]{report}


%%
%% EDIT THE BELOW TO CUSTOMIZE
%%

\def\authorname{Khalid Aleem\xspace}
\def\authorcollege{Trinity College\xspace}
\def\authoremail{ka476@cam.ac.uk}
\def\dissertationtitle{A Risc-V based co-processor peripheral to accelerate CNN inference.}
% Maximising throughput for a Risc-V linear algebra co-processor.
\def\wordcount{14,235}


%\usepackage[dvips]{epsfig,graphics} 
\usepackage{epsfig,graphicx,verbatim,parskip,tabularx,setspace,xspace}

\usepackage{booktabs}
\usepackage{amsmath,amssymb}
\usepackage{fancyvrb,listings}

\usepackage[a4paper, margin=1in]{geometry}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{blue!40!black},
  commentstyle=\itshape\color{purple!40!black},
  stringstyle=\color{green!40!black},
  morekeywords={uint32_t,uint8_t}
}


%% START OF DOCUMENT
\begin{document}


%% FRONTMATTER (TITLE PAGE, DECLARATION, ABSTRACT, ETC) 
\pagestyle{empty}
\singlespacing
\input{titlepage}
\onehalfspacing
\input{declaration}
\singlespacing
\input{abstract}

\pagenumbering{roman}
\setcounter{page}{0}
\pagestyle{plain}
\tableofcontents
\listoffigures
\listoftables

\onehalfspacing


\chapter{Introduction}
\pagenumbering{arabic} 
\setcounter{page}{1} 

% NOTE: Clear motivation - justify the benefits of success
% NOTE: Contextualise what i'm building
% NOTE: Analysis of requirements and justified & documented use of tools!


% Work on Story
% Embedded Devices
% Common for embedded devices to have their own acclerators
% RiscV - ^ - 


% What are our main contributions:
% Improved upon/got working (FPU) testbench (verilator) for rapid prototyping and simulations
% Wrote functioning bare-metal firmware for a RiscV CPU

% Accelerator: VLIW/Superscalar execution

% Bluespec: Customisable number of functional units, varying silicon area.
% In the best case, obtained an approx 10x speed-up through hardware buffered
% commands. 


\chapter{Background} 
\section{Risc-V Instruction Set}
Risc-V is an open standard instruction set architecture (ISA). It is provided
under open source licenses, where anybody may use the ISA, with no restrictions
over the use of intellectual property (IP). In contrast the widely-used,
especially in embedded devices, ARM ISA, is proprietary. If the ARM ISA is used
for commercial purposes, the company expects a licencing deal to be made and
royalties to be paid. Licencing deals typically cost millions of dollars and can
take months to negotiate. These IP restrictions hinder the process of academic
research, and significantly raise the barrier of entry for processor design,
where only large companies like Qualcomm can compete.

As such, there is no incentive for processor designs to be made open source.
Obtaining the source code of most ARM processors is both difficult and
impractical due to these strict and costly licencing requirements.

% TODO: Risc-V cite: https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-146.html 
Since the publication of the Risc-V ISA, a variety of different open source
processors have been designed that are based on the open standard Risc-V ISA.
The source code of these processors is publically available, with a range of
different designs available on GitHub.

Collaboration and open source processor
design has a range of additional benefits in architectural security. This is of
particular relevance in the light of severe hardware-level vulnerabilities found
in the majority of ARM and x86\_64 processors in production, namely Spectre, and
Meltdown. With processor designers and manufacturers paying less attention to
verifying the security of their devices whilst competing with each other to
maximise processor throughput. Open source processor development allows for
processor designs to be verified by a community of different organisations, and
By basing our work on an open source processor in the development of our
peripheral, we benefit substantially from these security considerations.

When designing a peripheral, it is vital to possess an understanding of the
processor that it is connected to. Using an open source processor gives us
greater freedom, allowing us to pry into the internals, and analyse the
specifics of processor behaviour if things behave in an unexpected manner.


\section{Simulating Hardware}
% Risc-V
The fastest way to verify the design of hardware is through simulations.
\subsection{Verilator}
Verilator is a piece of open source software that compiles Verilog into C++. A
testbench can then be created, where the generated C++ class representing the
top-level module in hardware, can be stepped forwards in time with the clock
toggled from low to high accordingly, and signals propagated through simulated
hardware accordingly.

% https://www.veripool.org/papers/Verilator_Fast_Free_Me_DVClub10_pres.pdf
% TODO: Include example testbench


%\subsection{Bluesim}

% Spike

\section{FPGAs/Synthesis}
% TODO: Talk about modern processors structure - Internal FPGA - motivations
% Relate to Intel Acquisition of Altera --- (Recent) AMD Acquisition of Xilinx
% Looks inc

% TODO: Silicon surface? Embedded systems. - Which do I pick!?
%  Mainly ^^ 

% TODO: Toolchains
% Xilinx Vivado
% Symbiflow

\section{ChiselHDL \& SpinalHDL}
% Features --- ChiselHDL + Risc-V

\section{Bluespec Verilog}
% Features
% Example code / Comparisons
% Benefits

\chapter{Related Work} 
\section{Open Source Hardware}

\section{BlueVec}
% https://www.cl.cam.ac.uk/~swm11/papers/FPL2013-BlueVec.pdf
The BlueVec co-processor is a vector processor aimed at accelerating neural
network inference designed to address the \emph{memory wall}. The memory wall
refers to the growing discrepancy between memory bandwidth and compute power. It
is increasingly common for an accelerator system to become memory-bound, where
the latency/clock cycle cost of moving data to and from memory may even exceed
the reduction in compute cycles from having a custom accelerator pipeline.

The BlueVec co-processor relies on the observation that in many situations where
a custom accelerator pipeline is implemented to accelerate some computation
through performing it in hardware, a significant improvement may be demonstrated
by vectorizing the computation, and implementing the computation within
software. The paper demonstrates the example of neural network inference, where
the BlueVec co-processor is used in the context of a digit recognition problem.

The BlueVec co-processor is designed in Bluespec Verilog, %

% 
The BlueVec co-processor is used, and accessed 


% TODO: BlueVec - Literature Review
% TODO: ZynqNet - Literature Review
% Rocket RoCC - Literature Review
% Google TPU? & Nvidia GPUs? --- Look into


% NOTE: General argument --- elaborate upon motivations
% NOTE: BlueVec --- Nios. Custom instructions ---> Loss of interopability
% NOTE: Are there truly multiple functional units? Instructions STALL the cpu.
% NOTE: Unadjustable silicon consumption --- less control!

% NOTE: ZynqNet --- too SPECIFIC, NN architecture needed beforehand.


\section{}

% Bluespec Verilog

% SIMD


% TODO: image of SoC
% CPU/AXI4 e.t.c.
% Piccolo
% VexRiscV
% Rocket
% SiFive Freedom E310
\subsection{ARM Cortex M0/M3}
\subsection{Freedom E310}
\subsection{VexRiscV}

\chapter{Design and Implementation}

% NOTE: Main contribution to (the field?)
% NOTE: Original implementation
% NOTE: Somehow demonstrate - extra-curricular reading?!
% NOTE: Compare the design to BlueVec!?

% NOTE: Challenging goals - substantial deliverables

% NOTE: Design decisions

% Test bench --- functional
% Floating point unit (mstatus csr)
% RV32imafc - bare metal ELF
% Linker file, bare metal
% Spike, proxy kernel
% Bare Metal LibC - RiscV
% Heap memory!

% Cost of movement...

% Matrix multiplication
% Naive implementation
% Unit duplication NAIVE
% Unit duplication - scheduling
% Copy cost

% ZipReduceUnitServer - improvements + bench
% Unit duplication - special memory & wire connections!
%


% RegFile vs Vector#(Reg#()) vs BRAM


\section{SoC Design}
\subsection{Piccolo}

\subsection{AXI4 Protocol}
% TODO: OR IN Test Peripheral (AXI4)
% TODO: Background info/filler and origin
\texttt{wstrb}
% TODO: How is memory read/written from

The AXI4 protocol comes with the disadvantage of being able write a maximum of 4
bytes per request on 32-bit systems. Each request, orchestrated by the CPU,
spans multiple clock cycles.




% TODO: To what extent does this 

\section{Testbench Setup}
\subsection{Risc-V Assembly \& Firmware Structure}
The firmware which runs on an embedded Risc-V core is significantly different to
software that runs on top of an operating system. In order to compile C and
assembly language into machine code, we make use of the GNU compiler collection
(GCC).

The naming convention for compilers is \texttt{arch-vendor-os-libc-gcc}. The
standard, desktop version of gcc \texttt{x86\_64-pc-linux-gnu-gcc} is not
capable of producing Risc-V machine code. Moreover, it is targetted at the linux
operating system, and uses the linux GNU LibC and supports linux system calls.
In order to compile our Risc-V assembly and C into Risc-V machine code, we must
use a cross-compiler. We build a compiler on our host x86\_64 system to run on
an x86\_64 machine, that is capable of producing a Risc-V ELF binary.

The \texttt{riscv64-unknown-elf-gcc} compiler is designed to produce a
bare-metal Risc-V binary. Instead of using GNU LibC, the C library used is
Newlib. Newlib is C library that is designed for embedded systems. With Newlib,
we now have access to the standard C functions for IO \texttt{printf}, and math
functions, such as \texttt{pow}, and \texttt{sqrt}. The relevant machine code
for these functions are statically linked, and the code within our final binary
ELF is entirely self-contained. This can be seen in the section layout of our
produced ELF file.

Relevant sections of our final ELF file. We have a stack,  
\tiny
\begin{verbatim}
Section ._stack         : addr         800000f8 to addr         80010100; size 0x   10008 (= 65544) bytes
Section .text.pow       : addr         80013444 to addr         8001352e; size 0x      ea (= 234) bytes
Section .text.__ieee754_pow: addr         8001352e to addr         80013fee; size 0x     ac0 (= 2752) bytes
Section .text.__ieee754_sqrt: addr         80013fee to addr         800141b4; size 0x     1c6 (= 454) bytes
Section .text.memcpy    : addr         8001707c to addr         80017164; size 0x      e8 (= 232) bytes
\end{verbatim}
\normalsize



\subsubsection{UART/Serial Output}
The most important firmware debugging feature to get working is the ability to
print to console. The Piccolo techbench SoC kindly contains a NS16550 UART
peripheral that is connected to 

This UART peripheral is memory mapped. 

\subsubsection{Printf}

\subsubsection{LibC --- NewLib}


\subsubsection{Linker File}

One of the first problems encountered was a CPU trap due to a stack overflow.
The size of the stack may be modified in the linker file. The embeddedartistry
printf implementation that avoids using heap memory stores a considerable amount
of data on the stack. As such, the stack needs to be modified.   
% TODO: Avoiding stack overflow
% TODO: 


\subsection{Floating Point Unit}
\subsubsection{Fixing Piccolo FPU typeerrors}
The latest commit of the Piccolo processor, at the time of development, (), had
a type error in the floating point unit (FPU). 

The compiler experiences ambiguity between the RoundMode's declared in. We must enter, FPU.bsv and FBox\_Core.bsv and prefix the RoundMode type with FloatingPoint::RoundMode.

% NOTE: Compile log
\begin{verbatim}
compiling Piccolo/src_Core/CPU/FPU.bsv
Warning: Unknown position: (S0080)
1 warnings were suppressed.
Error: "Piccolo/src_Core/CPU/FPU.bsv", line 52, column 30: (T0080)
Type error at the use of the following function:
mkFloatingPointDivider

The expected return type of the function:
g__#(ClientServer::Server#(Tuple3#(FPU::FSingle, FPU::FSingle, ISA_Decls::RoundMode), FPU::FpuR))

The return type according to the use:
c__#(ClientServer::Server#(Tuple3#(FloatingPoint::FloatingPoint#(d__, e__),
FloatingPoint::FloatingPoint#(d__, e__),
FloatingPoint::RoundMode),
Tuple2#(FloatingPoint::FloatingPoint#(d__, e__), FloatingPoint::Exception)))
\end{verbatim}

\subsubsection{mstatus CSR}
Once the FPU is successfully compiled, and the processor is compiled with
floating point support, the processor will trap and throw an exception when any
floating point instruction is executed. When a processor exception takes place,
the processor moves the program counter back to the start of the boot ROM, this
is observed in the simulation output as an infinite loop, where code after the
first floating point instruction will never execute, as the program will
constantly restart.

With an open source processor, we have the ability to inspect and modify the
source code, and recompile the processor. We can instruct the CPU to print its
internal state when a trap occurs, notably: information about the trap, and the
type of exception that has been thrown. With this information, we can look
through the codebase of the Piccolo processor, and identify what is causing the
processor to fail to execute floating point instructions, despite the fact that
the FPU module is included within the processor.

We enter \texttt{CPU.bsv}, and modify the rule responsible for modifying the
behaviour of the CPU when the trap condition is met. We display additional
information about the trap, and instruct the simulation to end when a trap
occurs. This is where BluespecVerilog is incredibly useful. The
\texttt{Trap\_Info} structure within BSV contains the \texttt{FShow} typeclass.
This contains information for printing the structure in a clean and easy-to-read
way, specifically for debugging purposes. Additionally, the
\texttt{fshow\_trap\_Exc\_Code} function will print the human-readable name of
the exception code enumeration. As such, we do not need to constantly switch
between looking at our program output, and figuring out what the output
represents in our source code files.
% CPU.bsv
% TODO: BSV
\begin{lstlisting}[language=C,style=customc]
   rule rl_trap ((rg_state == CPU_TRAP)
		 && (stage1.out.ostatus != OSTATUS_BUSY));

      [...]

      $display("DEBUG: CPU TRAP: ", fshow(rg_trap_info));
      $display("Exc_Code: ", fshow_trap_Exc_Code(exc_code));
      $finish(0);
   endrule: rl_trap
\end{lstlisting}

The information we obtain about our processor trap can be matched to the
specific address in assembly code that causes the error. In this particular
case, the \texttt{flw} instruction is responsible for triggering an
\texttt{ILLEGAL\_INSTRUCTION} exception.
\begin{lstlisting}[language=C,style=customc]
  float a = 1.0f;
  // Assembly:
  // 80002276: lui a5, 0x80001
  // 8000227a: flw fa5,424(a5)
  // 8000227e: fsw fa5,-28(s0)
  // Prints:
  // Trap_Info { epc: 'h8000227a, exc_code: 'h2, tval: 'h1a87a787 }
  // Exc_Code: ILLEGAL_INSTRUCTION
\end{lstlisting}

We look through our processor code, and identify the locations where this
particular exception code is set. We observe that it is set in the
\texttt{alu\_outputs\_base} struct within \texttt{EX\_ALU\_functions.bsv}. This
struct is copied within the ALU function that corresponds to loading data into
registers, \texttt{fv\_LD}. If the \texttt{flw} instruction is called, a
particular bit on the \texttt{mstatus} control-status register (CSR) is read. In
our case, the fs bit is found to be disabled.
\begin{lstlisting}[language=C,style=customc]
function ALU_Outputs fv_LD (ALU_Inputs inputs);
   [...]
   // FP loads are not legal unless the MSTATUS.FS bit is set
   Bool legal_FP_LD = True;
`ifdef ISA_F
   if (opcode == op_LOAD_FP)
      legal_FP_LD = (fv_mstatus_fs (inputs.mstatus) != fs_xs_off);
`endif
   let alu_outputs = alu_outputs_base;

   alu_outputs.control   = ((legal_LD && legal_FP_LD) ? CONTROL_STRAIGHT
                                                      : CONTROL_TRAP);
   [...]
   return alu_outputs;
endfunction
\end{lstlisting}

Compared to debugging standard Verilog, the structure of Bluespec Verilog
provides us with a greater ability to debug, and identify relevant codepaths.

We further observe that all FP ALU functions check the fs bit of the CSR register.
This can be seen from the ALU fv\_LD function that runs when the flw instruction
is executed. We later learn, that this is an intentional design descision as per
the Risc-V specification, Chapter 3, Section 1.11. The fs bit on the mstatus CSR must be
set in order for floating-point instructions to be enabled. We can see how this
is done in bare-metal C, by looking at the source code for the Spike Risc-V
proxy kernel, we implement the relevant parts of this code within our firmware
initialisation sequence. Once implemented, we observe that floating point
instructions operate correctly.
% https://github.com/riscv/riscv-pk/blob/master/machine/minit.c
% https://github.com/riscv/riscv-pk/blob/master/machine/encoding.h 
\begin{lstlisting}[language=C,style=customc]

// encoding.h
#define MSTATUS_FS          0x00006000
#define write_csr(reg, val) ({ \
  asm volatile ("csrw " #reg ", %0" :: "rK"(val)); })

// minit.c
static void mstatus_init()
{
  uintptr_t mstatus = 0;
  // Enable FPU
  if (supports_extension('F'))
    mstatus |= MSTATUS_FS;
  [...]
  write_csr(mstatus, mstatus);
  [...]
}

\end{lstlisting}



% TODO: Citation
% “The RISC-V Instruction Set Manual, Volume II: Privileged Architecture,
% Document Version 20190608-Priv-MSU-Ratified”, Editors Andrew Waterman and
% Krste Asanovi´c, RISC-V Foundation, June 2019
% https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf
% TODO: Citation (Spike) + RiscV PK

\subsection{Test Peripheral (AXI4)}
When building a peripheral, it is important to first work constructively from a
minimum functioning unit. In order for our embedded processor to communicate
with with our peripheral, we make use of memory-mapped I/O. We map a small
unoccupied memory address range to our peripheral, and give it a small internal
region of memory where 4-byte integers can be read/written from.

The AXI4 protocol is designed by ARM, and is royalty-free, where a licence is
not required for academic or commercial use.

% https://forums.xilinx.com/t5/Design-and-Debug-Techniques-Blog/AXI-Basics-1-Introduction-to-AXI/ba-p/1053914 

% AXI4 RAM: https://github.com/alexforencich/verilog-axi/blob/master/rtl/axi_ram.v 

% 10 wire write address channel
% 5 wire write data channel
% 4 wire write response channel
% 10 wire read address channel
% 6 wire read data channel
% 35 wires in total, excluding clock & reset

Due to the inherent complexity of the AXI4 protocol, large combinatorial finite
state machines are required to ensure the read and
write requests of the AXI4 bus are processed correctly. The state of over a
dozen wires needs to be considered by the programmer on every clock cycle.
Developing a peripheral in this manner is a challenging feat.

Moreover, when a peripheral for the module is initialised, all 35 wires
corresponding to signals in the AXI4 protocol need to be connected to the AXI4
interconnect. All of these connections need to be manually specified. This can
be observed in Verilog RTL as follows:


\tiny
\begin{verbatim}
  mkUART uart0(.CLK(CLK),
	       .RST_N(RST_N),
	       .put_from_console_put(uart0$put_from_console_put),
	       .set_addr_map_addr_base(uart0$set_addr_map_addr_base),
	       .set_addr_map_addr_lim(uart0$set_addr_map_addr_lim),
	       .slave_araddr(uart0$slave_araddr),
	       .slave_arburst(uart0$slave_arburst),
	       .slave_arcache(uart0$slave_arcache),
	       .slave_arid(uart0$slave_arid),
	       .slave_arlen(uart0$slave_arlen),
	       .slave_arlock(uart0$slave_arlock),
	       .slave_arprot(uart0$slave_arprot),
	       .slave_arqos(uart0$slave_arqos),
	       .slave_arregion(uart0$slave_arregion),
	       .slave_arsize(uart0$slave_arsize),
	       .slave_arvalid(uart0$slave_arvalid),
	       .slave_awaddr(uart0$slave_awaddr),
	       .slave_awburst(uart0$slave_awburst),
	       .slave_awcache(uart0$slave_awcache),
	       .slave_awid(uart0$slave_awid),
	       .slave_awlen(uart0$slave_awlen),
	       .slave_awlock(uart0$slave_awlock),
	       .slave_awprot(uart0$slave_awprot),
	       .slave_awqos(uart0$slave_awqos),
	       .slave_awregion(uart0$slave_awregion),
	       .slave_awsize(uart0$slave_awsize),
	       .slave_awvalid(uart0$slave_awvalid),
	       .slave_bready(uart0$slave_bready),
	       .slave_rready(uart0$slave_rready),
	       .slave_wdata(uart0$slave_wdata),
	       .slave_wlast(uart0$slave_wlast),
	       .slave_wstrb(uart0$slave_wstrb),
	       .slave_wvalid(uart0$slave_wvalid),
	       .EN_server_reset_request_put(uart0$EN_server_reset_request_put),
	       .EN_server_reset_response_get(uart0$EN_server_reset_response_get),
	       .EN_set_addr_map(uart0$EN_set_addr_map),
	       .EN_get_to_console_get(uart0$EN_get_to_console_get),
	       .EN_put_from_console_put(uart0$EN_put_from_console_put),
	       .RDY_server_reset_request_put(uart0$RDY_server_reset_request_put),
	       .RDY_server_reset_response_get(uart0$RDY_server_reset_response_get),
	       .RDY_set_addr_map(),
	       .slave_awready(uart0$slave_awready),
	       .slave_wready(uart0$slave_wready),
	       .slave_bvalid(uart0$slave_bvalid),
	       .slave_bid(uart0$slave_bid),
	       .slave_bresp(uart0$slave_bresp),
	       .slave_arready(uart0$slave_arready),
	       .slave_rvalid(uart0$slave_rvalid),
	       .slave_rid(uart0$slave_rid),
	       .slave_rdata(uart0$slave_rdata),
	       .slave_rresp(uart0$slave_rresp),
	       .slave_rlast(uart0$slave_rlast),
	       .get_to_console_get(uart0$get_to_console_get),
	       .RDY_get_to_console_get(uart0$RDY_get_to_console_get),
	       .RDY_put_from_console_put(uart0$RDY_put_from_console_put),
	       .intr(uart0$intr));
\end{verbatim}
\normalsize

Bluespec Verilog offers a significant degree of abstraction when processing AXI4
read and write requests, and also when attaching the peripheral to the AXI4 bus interconnect.



\subsubsection{AXI4 write request}

In standard verilog, one must keep track of 

The AXI4 protocol 

\subsubsection{AXI4 Alignment/Padding}
This code results in the cpu trapping:
\begin{verbatim}
*((uint32_t\*)0xC0001002) = 1337;
Trap_Info { epc: 'h800022d6, exc_code: 'h6, tval: 'hc0001002 }
TRAP EXC: STORE_AMO_ADDR_MISALIGNED
The exception/trap code corresponds to:
\end{verbatim}

\subsubsection{Struct Padding}
% TODO: Introduce the need for struct padding/packing
This is of particular importance to consider when we issue a command to the
accelerator. In order to ensure 


\subsubsection{Firmware}
When a special execution bit is set, we set a special accelerator busy bit and
unset the execution bit. In a single cycle, within the accelerator, if the
busy bit is set, we double the array and unset the busy bit. This allows the
firmware to stall until the busy bit is unset, and the computation has been
completed.

Throughout this process, we make use of, and modify, the fully functioning test
bench provided by Piccolo as a basis for our simulations of the test peripheral.

% NOTE: Firmware C code for accelerator
\begin{lstlisting}[language=C,style=customc]
#define TEST_CONTROL_ADDR 0xC0001000UL
#define TEST_DATA_ADDR 0xC0001008UL
#define TEST_RANGE 4
void main() {
  for(int i=0; i<TEST_RANGE; i++) {
    *((uint32_t volatile*)TEST_DATA_ADDR+i) = i;
    uint32_t data = *((uint32_t*)TEST_DATA_ADDR+i);
    printf("%d: %d\n", i, data);
  }

  println("Set Control Bit..");
  *((uint8_t volatile*)TEST_CONTROL_ADDR) |= 1;

  while(*((uint8_t volatile*)TEST_CONTROL_ADDR) & 2 == 0) {}
  println("Stalling.."); // Printing Stalling... stalls anyway...

  println("Stall complete!");
  for(int i=0; i<TEST_RANGE; i++) {
    uint32_t data = *((uint32_t volatile*)TEST_DATA_ADDR+i);
    printf("%d: %d\n", i, data);
  }
}
\end{lstlisting}

% NOTE: Console log
\begin{verbatim}
0: 0
1: 1
2: 2
3: 3
Set Control Bit..
Stalling..
Stall complete!
0: 0
1: 2
2: 4
3: 6
\end{verbatim}

\section{Matrix Multiplication Peripheral}
\subsection{Overview}
Mathematically, the result of a matrix multiplication may be expressed
accordingly:
\begin{align*}
  C &= AB \\
  C_{ij} &= \sum_k A_{ik}B_{kj}
\end{align*}

Matrix multiplication may be expressed in a programmatic form as such:
\texttt{C[i][j] = sum zipWith (op*) (row A i) (col B j)}

When matrices are stored in memory, they can only be indexed with a single
dimension. A multi-dimensional matrix is represented as a multi-dimensional
array, this array is represented in memory in as a flattened contiguous
one-dimensional array, with the rows of the matrix next to each other in memory.

As such, we access the xth ro
$$ \text{IndexOf} A[x][y] = x + y * width(A) $$

This methodology of accessing the x, and y elements of a stored matrix is used
throughout the accelerator.

% TODO: Internal memory

% TODO: Register-file, vs Vector#(Reg#())
A contiguous region of memory, that exists within the FPGA block RAM,  
Our peripheral contains a RegFile of internal memory which is memory mapped to
the CPU via an AXI4 bus slave interface.

\subsection{Design Decisions}
\subsubsection{Hybrid/Monolithic}
% TODO: Citations - argue around, base ideas off.
We propose two potential ways of implementing matrix multiplication. We could
pursue a monolithic approach and implement the entire multiplication purely in
hardware. Alternatively, we could perform a hybrid approach, where each element
of \texttt{C[i][j]} may be computed by issuing a separate command to the
accelerator. This is proposed under the idea that the creation and scheduling of
instructions for each element in the final matrix, is more easily performed
within the firmware of the embedded processor.

\subsubsection{Memory Regions}
We split our accelerator 
\begin{table}
  \centering
\begin{tabular}{lll}
  \toprule
  Offset Address Range & Size & Purpose \\
  \midrule
  \texttt{0x0000-0x0020} & 32 Bytes & Status \\
  \texttt{0x0020-0x0040} & 32 Bytes & Control \\
  \texttt{0x0040-0x1000} & $\approx$ 4 KB & Memory \\
  \bottomrule
\end{tabular}
\end{table}

\subsubsection{Status}
The first byte of our status memory is to monitor, and control execution from
the accelerator.

\subsubsection{Control}
We write our control command/instruction to the control memory bank. We then set out
execute status bit, and the accelerator should run the appropriate command.

\subsubsection{Memory}


\subsection{Command Issuing \& Decoding}
One of the principal problems encountered between issuing a command containing
a struct of multi-byte data to the accelerator from the embedded processor. By
default, the unsigned integer type in BSV is in big endian form, while the
embedded core stores data in little endian form. The motivation for embedded
processors to use little endian byte ordering is to ensure that the address of a
variable is unchanged when a typecast is performed. This saves processor cycles,
and results in improved performance. Variables are automatically
truncated/extended when an appropriate typecast is made. \\

We write a C struct into our control region of memory. In order for the data
within the instructions to be interpreted correctly in hardware, the
byte-ordering needs to be reversed. BSV provides us with a systematic and clean
way of doing this within hardware. The alternative would be to reverse the bytes
in software, and therefore lose cycles. \\

% TODO: Link to:
% https://github.com/jeffreycassidy/BlueLink/blob/master/Core/Endianness.bsv 

% TODO: C padding - citations
Naturally, C structures are padded and aligned, where 4-byte variables are
aligned to the nearest 4-bytes. Previous variables are extended in size in
accordance to this padding. To ensure cleanliness 

\subsection{Functional Unit Design}
BSV contains a FloatingPoint library. Modules already exist for addition and
multiplication which extend the Server module. 

We can put a request, and after some number of clock cycles, get a response.

\subsubsection{Fused Multiply-Accumulate}


\subsubsection{Pipelined Multiplication with Addition}
\subsubsection{Pipelined Multiplication \& Pairwise Addition}
\subsubsection{Predicted Performance}
% Unit Design: TODO: Include diagram

% Unit: Memory Parallelism
% Unit: Memory Banking:

\subsection{Multiple Functional Units}
% TODO: Naive. READ/WRITE ports


% TODO: Evaluation of results: ~10x faster
% TODO: Explanation of results
% 

% TODO: Jesus...
\subsection{Multi-Ported Memory}

% What is a Regfile, What is BlockRam? What is SRAM?
We observe that a RegFile, has a maximum of 5 read ports, and 1 write port.
Typically, BRAM, has 2 read ports, and 1 write port.

% Error: "MultiPortBRAM.bsv", line 18, column 37: (G0002)
% `pmem_mem_0.sub' needs more than 5 ports for the following uses:
% `pmem_mem_0.sub a__h30554' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h31995' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32028' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32061' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32094' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32127' at "MultiPortBRAM.bsv", line 18, column 37

\subsubsection{Memory Striping}

\subsection{Rule conflicts, rapid execution}

% TODO: UNKNOWN TIMINGS?:
% TODO: Cycle count / byte read in IO memory (when bypassing the cache!?)
% TODO: CACHE R/W speed!?

\section{Commmunication \& Memory Bottleneck}
\subsection{Protocol efficiency/optimisation}
% Analysis of struct packing
% Attribute ((packed))
% uint8_t offset <-- redundant (-3 bytes)
% uint8_t unit <-- push to accelerator

% uintptr_t <-- Make ADDR 16 bits!?, subtract base address (64KB accel memory...) ()
% (-3*2=-6 bytes)
% 0xC0002900 --> 32 bits
% 2900 --> 16 bits
% 1000 (16-bit base address)
% 1900
% 6 bytes ~=? 6 cycles saved
% 2-4 cycles/base address subtraction
% ALIGN: ACCEL @ 16-bit base address boundary
% Therefore 0-cost LE typecast <---> address calculation! (SMART)


\subsection{Firmware Command Buffering}
% In firmware
% Stack Instruction Buffering
% In hardware
% Accelerator buffer/program counter. (Internal stack)

\begin{table}
  \centering
  \begin{tabular}{r|rr}
    \toprule
    Units & Peripheral & Processor\\
    \midrule
    0  &     ? & 21500 \\
    1  & 13366 & 13596 \\
    2  &  6817 &  7085 \\
    4  &  3670 &  3954 \\
    8  &  2621 &  2889 \\
    12 &  2666 &  2929 \\
    16 &  2633 &  2916 \\
    \bottomrule
  \end{tabular}
  \caption{Overhead: Buffer cycles: 723. Copy cycles: 4984}
\end{table}

\subsection{Firmware Stalling/Interrupts}
\subsection{Instruction jumping}
\subsection{Hardware Command Buffering}

\subsection{64-bit}

\begin{verbatim}
// MMIO PC
void __attribute__((noinline, section(".dummy_section"))) func_test() {
  print("Meme!\n");
}

// Linker script modified
extern unsigned char dummysec_start[];
extern unsigned char dummysec_end[];
void main() {
  //print("Hello, world!\n");
  //mstatus_init();
  //init_stack();

  //accel_buffered_test();

  // GOTO TEST!

  /* asm ("addi sp,sp,-4"); */
  /* uint32_t label_addr = &&label_test; */
  /* printf("Label Address: %X\n", label_addr); */

  uint32_t func_size = dummysec_end-dummysec_start;
  /* printf("Func Size: 0x%X\n", func_size); */
  /* for(int i=0; i<func_size+4>>2; i++){ */
  /*   uint32_t* ft = (uint32_t*)&func_test + i; */
  /*   printf("\t%X - %X\n", ft, *ft); */
  /* } */
  memcpy((void*)(ACCEL_STAT_ADDR+8), &func_test, func_size);
  /* printf("Func Size: 0x%X\n", func_size); */
  /* for(int i=0; i<func_size+4>>2; i++){ */
  /*   uint32_t* ft = (uint32_t*)(ACCEL_STAT_ADDR+8) + i; */
  /*   printf("\t%X - %X\n", ft, *ft); */
  /* } */
  /* // Move func_test TO stupid SoC chip! */
  //asm volatile ("call % " :: "r"(&func_test));

  ((void (*)(void))0x80010CB8)();
  ((void (*)(void))0xC0002008)(); // Processor stall indefinitely.
  print("Test");
}

func_test address: 80010C98
Meme!
\end{verbatim}




\chapter{Evaluation} 
\section{Methodology}
\subsection{Benchmarking \& Counting cycles}
From the Risc-V specification, we take a look at the mcycles and minstret
registers
.
\subsection{Synthesis}

\section{Accelerator}
% TODO: Example + study (Evaluation)
\subsection{Fused Multiply Accumulate}

% Cannot exploit pipelined nature of unit.
% Faster than individual FP multiply, then add. 10 cycles vs 14 cycles.

%  10: FSM Start
%  20: Init
%  40: PUT: 00000000 40800000 40800000
%  40: STATE_LOCK
% 140: 0: MulAcc Result: 41800000
% 140: STATE_READY
% 150: PUT: 41800000 40800000 40800000
% 150: STATE_LOCK
% 250: 1: MulAcc Result: 42000000
% 250: STATE_READY
% 260: PUT: 42000000 40800000 40800000
% 260: STATE_LOCK
% 360: 2: MulAcc Result: 42400000
% 360: STATE_READY
% 370: PUT: 42400000 40800000 40800000
% 370: STATE_LOCK
% 470: 3: MulAcc Result: 42800000
% 470: STATE_COMPLETE
% 480: Output: 42800000


\subsection{}

\begin{align*}
  T_{Naive}(N) &= 11+N + 4N \\
  &= 15 + 5N \\
  T_{FMA}(N) &= (10+1)N \\
             &= 11N \\
  T_{TADD}(N) &= max(10+N, 11+2\frac{N}{2} + \frac{N}{4} + ... + 16) \\
             &= 2N+27 
\end{align*}

% TODO: ARM Cortex benchmark

\subsection{MNIST Neural Network: Dense Layers}

\section{Synthesis}
\subsection{Implementation}
\subsection{Xilinx Arty A7-100T}

\chapter{Summary and Conclusions} 

% NOTE: Clearly present argument and demonstrate that success criteria were
% metal
% NOTE: Critical thought and interpretation of results
% NOTE: substantiate claims of success/novelty

% NOTE: Reflect on lessons learnt - 

\appendix
\singlespacing

\bibliographystyle{unsrt} 
%\bibliography{dissertation} 

\end{document}
