%% 
%% ACS project dissertation template. 
%% 
%% Currently designed for printing two-sided, but if you prefer to 
%% print single-sided just remove ",twoside,openright" from the 
%% \documentclass[] line below. 
%%
%%
%%   SMH, May 2010. 

\documentclass[a4paper,9pt]{report}
%\documentclass[a4paper,12pt,twoside,openright]{report}


%%
%% EDIT THE BELOW TO CUSTOMIZE
%%

\def\authorname{Khalid Aleem\xspace}
\def\authorcollege{Trinity College\xspace}
\def\authoremail{ka476@cam.ac.uk}
\def\dissertationtitle{A Risc-V based co-processor peripheral to accelerate CNN inference.}
% Maximising throughput for a Risc-V linear algebra co-processor.
\def\wordcount{14,235}


%\usepackage[dvips]{epsfig,graphics} 
\usepackage{epsfig,graphicx,verbatim,parskip,tabularx,setspace,xspace}

\usepackage{booktabs}
\usepackage{amsmath,amssymb}
\usepackage{fancyvrb,listings}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{blue!40!black},
  commentstyle=\itshape\color{purple!40!black},
  stringstyle=\color{green!40!black},
  morekeywords={uint32_t,uint8_t}
}


%% START OF DOCUMENT
\begin{document}


%% FRONTMATTER (TITLE PAGE, DECLARATION, ABSTRACT, ETC) 
\pagestyle{empty}
\singlespacing
\input{titlepage}
\onehalfspacing
\input{declaration}
\singlespacing
\input{abstract}

\pagenumbering{roman}
\setcounter{page}{0}
\pagestyle{plain}
\tableofcontents
\listoffigures
\listoftables

\onehalfspacing


\chapter{Introduction}
\pagenumbering{arabic} 
\setcounter{page}{1} 

% Work on Story
% Embedded Devices
% Common for embedded devices to have their own acclerators
% RiscV - ^ - 


% What are our main contributions:
% - Improved upon/got working (FPU) test bench, and
% firmware for rapid prototyping and simulations
% of a Risc-V based CPU
% Achieved an approx 5x speed-up - 



\chapter{Background} 
\section{Risc-V Instruction Set}

\section{Simulating Hardware}
% Risc-V
% Spike
% Verilator

\section{Synthesis of Hardware}
% Xilinx Vivado
% Symbiflow

\section{ChiselHDL \& SpinalHDL}
\section{Bluespec Verilog}
% Features
% Example code / Comparisons
% Benefits

\chapter{Related Work} 
\section{Open Source Hardware}
% Processors:
% BlueVec
% https://www.cl.cam.ac.uk/~swm11/papers/FPL2013-BlueVec.pdf

% Rocket RoCC
\section{}
% Google TPU?
% Nvidia GPUs?!

% Bluespec Verilog

% SIMD/

\chapter{Design and Implementation}
% Design decisions

% Test bench --- functional
% Floating point unit (mstatus csr)
% RV32imafc - bare metal ELF
% Linker file, bare metal
% Spike, proxy kernel
% Bare Metal LibC - RiscV
% Heap memory!

% Cost of movement...

% Matrix multiplication
% Naive implementation
% Unit duplication NAIVE
% Unit duplication - scheduling
% Copy cost

% endianness & packing

% ZipReduceUnitServer - improvements + bench
% Unit duplication - special memory & wire connections!
%


% RegFile vs Vector#(Reg#()) vs BRAM


\section{SoC Design}
% TODO: image of SoC
% CPU/AXI4 e.t.c.
% Piccolo
% VexRiscV
% Rocket
% SiFive Freedom E310
\subsection{ARM Cortex M0/M3}
\subsection{Freedom E500}
\subsection{VexRiscV}
\subsection{Piccolo}

\subsection{AXI4 Protocol}
% TODO: Background info/filler and origin
\texttt{wstrb}
% TODO: How is memory read/written from

The AXI4 protocol comes with the disadvantage of being able write a maximum of 4
bytes per request on 32-bit systems. Each request, orchestrated by the CPU,
spans multiple clock cycles.




% TODO: To what extent does this 

\section{Testbench Setup}
\subsection{Risc-V Assembly \& Firmware Structure}
The firmware which runs on an embedded Risc-V core is significantly different to
code that is ran on a standard computer. 

\subsubsection{Linker File}
% TODO: Avoiding stack overflow
% TODO: 

\subsection{Floating Point Unit}
\subsubsection{Fixing Piccolo FPU typeerrors}
The latest commit of the Piccolo processor, at the time of development, (), had
a type error in the floating point unit. 

The compiler experiences ambiguity between the RoundMode's declared in. We must enter, FPU.bsv and FBox\_Core.bsv and prefix the RoundMode type with FloatingPoint::RoundMode.

% NOTE: Compile log
\begin{verbatim}
compiling Piccolo/src_Core/CPU/FPU.bsv
Warning: Unknown position: (S0080)
1 warnings were suppressed.
Error: "Piccolo/src_Core/CPU/FPU.bsv", line 52, column 30: (T0080)
Type error at the use of the following function:
mkFloatingPointDivider

The expected return type of the function:
g__#(ClientServer::Server#(Tuple3#(FPU::FSingle, FPU::FSingle, ISA_Decls::RoundMode), FPU::FpuR))

The return type according to the use:
c__#(ClientServer::Server#(Tuple3#(FloatingPoint::FloatingPoint#(d__, e__),
FloatingPoint::FloatingPoint#(d__, e__),
FloatingPoint::RoundMode),
Tuple2#(FloatingPoint::FloatingPoint#(d__, e__), FloatingPoint::Exception)))
\end{verbatim}

\subsubsection{mstatus CSR}
Once the FPU is successfully compiled, and the processor is compiled with
floating point support, the processor will trap and throw an exception when any
floating point instruction is executed. When a processor exception takes place,
the processor moves the program counter back to the start of the boot ROM, this
is observed in the simulation output as an infinite loop, where code after the
first floating point instruction will never execute, as the program will
constantly restart.

With an open source processor, we have the ability to inspect and modify the
source code, and recompile the processor. We can instruct the CPU to print its
internal state when a trap occurs, notably: information about the trap, and the
type of exception that has been thrown. With this information, we can look
through the codebase of the Piccolo processor, and identify what is causing the
processor to fail to execute floating point instructions, despite 


% CPU.bsv
% TODO: BSV
\begin{lstlisting}[language=C,style=customc]
   rule rl_trap ((rg_state == CPU_TRAP)
		 && (stage1.out.ostatus != OSTATUS_BUSY));

      [...]

      $display("DEBUG: CPU TRAP: ", fshow(rg_trap_info));
      $display("Exc_Code: ", fshow_trap_Exc_Code(exc_code));
      $finish(0);
   endrule: rl_trap
\end{lstlisting}
\begin{lstlisting}[language=C,style=customc]
  float a = 1.0f;
  // Assembly:
  // 80002276: lui a5, 0x80001
  // 8000227a: flw fa5,424(a5)
  // 8000227e: fsw fa5,-28(s0)
  // Prints:
  // Trap_Info { epc: 'h8000227a, exc_code: 'h2, tval: 'h1a87a787 }
  // Exc_Code: ILLEGAL_INSTRUCTION
\end{lstlisting}

% EX_ALU_functions.bsv --> fv_LD
We observe that all FP ALU functions check the fs bit of the CSR register.
This can be seen from the ALU fv\_LD function that runs when the flw instruction
is executed.
\begin{lstlisting}[language=C,style=customc]
function ALU_Outputs fv_LD (ALU_Inputs inputs);
   [...]
   // FP loads are not legal unless the MSTATUS.FS bit is set
   Bool legal_FP_LD = True;
`ifdef ISA_F
   if (opcode == op_LOAD_FP)
      legal_FP_LD = (fv_mstatus_fs (inputs.mstatus) != fs_xs_off);
`endif
   let alu_outputs = alu_outputs_base;

   alu_outputs.control   = ((legal_LD && legal_FP_LD) ? CONTROL_STRAIGHT
                                                      : CONTROL_TRAP);
   [...]
   return alu_outputs;
endfunction
\end{lstlisting}

We later learn, that this is an intentional design descision as per the Risc-V
specification, Chapter 3, Section 1.11. The fs bit on the mstatus CSR must be
set in order for floating-point instructions to be enabled. We can see how this
is done in bare-metal C, by looking at the source code for the Spike Risc-V
proxy kernel.

% TODO: Citation
% “The RISC-V Instruction Set Manual, Volume II: Privileged Architecture,
% Document Version 20190608-Priv-MSU-Ratified”, Editors Andrew Waterman and
% Krste Asanovi´c, RISC-V Foundation, June 2019
% https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf
% TODO: Citation (Spike) + RiscV PK

\subsection{Test Peripheral (AXI4)}
When building a peripheral, it is important to first work constructively from a
minimum functioning unit. In order for our embedded processor to communicate
with with our peripheral, we make use of memory-mapped I/O. We map a small
unoccupied memory address range to our peripheral, and give it a small internal
region of memory where 4-byte integers can be read/written from.

\subsubsection{AXI4 Alignment/Padding}
This code results in the cpu trapping:
\begin{verbatim}
*((uint32_t\*)0xC0001002) = 1337;
Trap_Info { epc: 'h800022d6, exc_code: 'h6, tval: 'hc0001002 }
TRAP EXC: STORE_AMO_ADDR_MISALIGNED
The exception/trap code corresponds to:
\end{verbatim}

\subsubsection{Struct Padding}
% TODO: Introduce the need for struct padding/packing
This is of particular importance to consider when we issue a command to the
accelerator. In order to ensure 


\subsubsection{Firmware}
When a special execution bit is set, we set a special accelerator busy bit and
unset the execution bit. In a single cycle, within the accelerator, if the
busy bit is set, we double the array and unset the busy bit. This allows the
firmware to stall until the busy bit is unset, and the computation has been
completed.

Throughout this process, we make use of, and modify, the fully functioning test
bench provided by Piccolo as a basis for our simulations of the test peripheral.

% NOTE: Firmware C code for accelerator
\begin{lstlisting}[language=C,style=customc]
#define TEST_CONTROL_ADDR 0xC0001000UL
#define TEST_DATA_ADDR 0xC0001008UL
#define TEST_RANGE 4
void main() {
  for(int i=0; i<TEST_RANGE; i++) {
    *((uint32_t volatile*)TEST_DATA_ADDR+i) = i;
    uint32_t data = *((uint32_t*)TEST_DATA_ADDR+i);
    printf("%d: %d\n", i, data);
  }

  println("Set Control Bit..");
  *((uint8_t volatile*)TEST_CONTROL_ADDR) |= 1;

  while(*((uint8_t volatile*)TEST_CONTROL_ADDR) & 2 == 0) {}
  println("Stalling.."); // Printing Stalling... stalls anyway...

  println("Stall complete!");
  for(int i=0; i<TEST_RANGE; i++) {
    uint32_t data = *((uint32_t volatile*)TEST_DATA_ADDR+i);
    printf("%d: %d\n", i, data);
  }
}
\end{lstlisting}

% NOTE: Console log
\begin{verbatim}
0: 0
1: 1
2: 2
3: 3
Set Control Bit..
Stalling..
Stall complete!
0: 0
1: 2
2: 4
3: 6
\end{verbatim}

\section{Matrix Multiplication Peripheral}
\subsection{Overview}
Mathematically, the result of a matrix multiplication may be expressed
accordingly:
\begin{align*}
  C &= AB \\
  C_{ij} &= \sum_k A_{ik}B_{kj}
\end{align*}

Matrix multiplication may be expressed in a programmatic form as such:
\texttt{C[i][j] = sum zipWith (op*) (row A i) (col B j)}

% TODO: Internal memory

% TODO: Register-file, vs Vector#(Reg#())
Our peripheral contains a RegFile of internal memory which is memory mapped to
the CPU via an AXI4 bus slave interface.

\subsection{Design Decisions}
\subsubsection{Hybrid/Monolithic}
% TODO: Citations - argue around, base ideas off.
We propose two potential ways of implementing matrix multiplication. We could
pursue a monolithic approach and implement the entire multiplication purely in
hardware. Alternatively, we could perform a hybrid approach, where each element
of \texttt{C[i][j]} may be computed by issuing a separate command to the
accelerator. This is proposed under the idea that the creation and scheduling of
instructions for each element in the final matrix, is more easily performed
within the firmware of the embedded processor.

\subsubsection{Memory Regions}
We split our accelerator 
\begin{table}
  \centering
\begin{tabular}{lll}
  \toprule
  Offset Address Range & Size & Purpose \\
  \midrule
  \texttt{0x0000-0x0020} & 32 Bytes & Status \\
  \texttt{0x0020-0x0040} & 32 Bytes & Control \\
  \texttt{0x0040-0x1000} & $\approx$ 4 KB & Memory \\
  \bottomrule
\end{tabular}
\end{table}

\subsubsection{Status}
The first byte of our status memory is to monitor, and control execution from
the accelerator.

\subsubsection{Control}
We write our control command/instruction to the control memory bank. We then set out
execute status bit, and the accelerator should run the appropriate command.

\subsubsection{Memory}


\subsection{Command Issuing \& Decoding}
One of the principal problems encountered between issuing a command containing
a struct of multi-byte data to the accelerator from the embedded processor. By
default, the unsigned integer type in BSV is in big endian form, while the
embedded core stores data in little endian form. The motivation for embedded
processors to use little endian byte ordering is to ensure that the address of a
variable is unchanged when a typecast is performed. This saves processor cycles,
and results in improved performance. Variables are automatically
truncated/extended when an appropriate typecast is made. \\

We write a C struct into our control region of memory. In order for the data
within the instructions to be interpreted correctly in hardware, the
byte-ordering needs to be reversed. BSV provides us with a systematic and clean
way of doing this within hardware. The alternative would be to reverse the bytes
in software, and therefore lose cycles. \\

% TODO: Link to:
% https://github.com/jeffreycassidy/BlueLink/blob/master/Core/Endianness.bsv 

% TODO: C padding - citations
Naturally, C structures are padded and aligned, where 4-byte variables are
aligned to the nearest 4-bytes. Previous variables are extended in size in
accordance to this padding. To ensure cleanliness 

\subsection{Functional Unit Design}
BSV contains a FloatingPoint library. Modules already exist for addition and
multiplication which extend the Server module. 

We can put a request, and after some number of clock cycles, get a response.

\subsubsection{Fused Multiply-Accumulate}


\subsubsection{Pipelined Multiplication with Addition}
\subsubsection{Pipelined Multiplication \& Pairwise Addition}
\subsubsection{Predicted Performance}
% Unit Design: TODO: Include diagram

% Unit: Memory Parallelism
% Unit: Memory Banking:

\subsection{Multiple Functional Units}
% TODO: Naive. READ/WRITE ports


% TODO: Evaluation of results: ~10x faster
% TODO: Explanation of results
% 

% TODO: Jesus...
\subsection{Multi-Ported Memory}

% What is a Regfile, What is BlockRam? What is SRAM?
We observe that a RegFile, has a maximum of 5 read ports, and 1 write port.
Typically, BRAM, has 2 read ports, and 1 write port.

% Error: "MultiPortBRAM.bsv", line 18, column 37: (G0002)
% `pmem_mem_0.sub' needs more than 5 ports for the following uses:
% `pmem_mem_0.sub a__h30554' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h31995' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32028' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32061' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32094' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32127' at "MultiPortBRAM.bsv", line 18, column 37

\subsubsection{Memory Striping}

\subsection{Rule conflicts, rapid execution}

% TODO: UNKNOWN TIMINGS?:
% TODO: Cycle count / byte read in IO memory (when bypassing the cache!?)
% TODO: CACHE R/W speed!?

\section{Commmunication \& Memory Bottleneck}
\subsection{Protocol efficiency/optimisation}
% Analysis of struct packing
% Attribute ((packed))
% uint8_t offset <-- redundant (-3 bytes)
% uint8_t unit <-- push to accelerator

% uintptr_t <-- Make ADDR 16 bits!?, subtract base address (64KB accel memory...) ()
% (-3*2=-6 bytes)
% 0xC0002900 --> 32 bits
% 2900 --> 16 bits
% 1000 (16-bit base address)
% 1900
% 6 bytes ~=? 6 cycles saved
% 2-4 cycles/base address subtraction
% ALIGN: ACCEL @ 16-bit base address boundary
% Therefore 0-cost LE typecast <---> address calculation! (SMART)


\subsection{Command Buffering}
% In firmware
% Stack Instruction Buffering
% In hardware
% Accelerator buffer/program counter. (Internal stack)

\subsection{64-bit}
\begin{table}
  \centering
  \begin{tabular}{r|rr}
    \toprule
    Units & Peripheral & Processor\\
    \midrule
    0  &     ? & 21500 \\
    1  & 13366 & 13596 \\
    2  &  6817 &  7085 \\
    4  &  3670 &  3954 \\
    8  &  2621 &  2889 \\
    12 &  2666 &  2929 \\
    16 &  2633 &  2916 \\
    \bottomrule
  \end{tabular}
  \caption{Overhead: Buffer cycles: 723. Copy cycles: 4984}
\end{table}


\subsection{Firmware Stalling/Interrupts}

\subsection{Instruction jumping}

\begin{verbatim}
// MMIO PC
void __attribute__((noinline, section(".dummy_section"))) func_test() {
  print("Meme!\n");
}

// Linker script modified
extern unsigned char dummysec_start[];
extern unsigned char dummysec_end[];
void main() {
  //print("Hello, world!\n");
  //mstatus_init();
  //init_stack();

  //accel_buffered_test();

  // GOTO TEST!

  /* asm ("addi sp,sp,-4"); */
  /* uint32_t label_addr = &&label_test; */
  /* printf("Label Address: %X\n", label_addr); */

  uint32_t func_size = dummysec_end-dummysec_start;
  /* printf("Func Size: 0x%X\n", func_size); */
  /* for(int i=0; i<func_size+4>>2; i++){ */
  /*   uint32_t* ft = (uint32_t*)&func_test + i; */
  /*   printf("\t%X - %X\n", ft, *ft); */
  /* } */
  memcpy((void*)(ACCEL_STAT_ADDR+8), &func_test, func_size);
  /* printf("Func Size: 0x%X\n", func_size); */
  /* for(int i=0; i<func_size+4>>2; i++){ */
  /*   uint32_t* ft = (uint32_t*)(ACCEL_STAT_ADDR+8) + i; */
  /*   printf("\t%X - %X\n", ft, *ft); */
  /* } */
  /* // Move func_test TO stupid SoC chip! */
  //asm volatile ("call % " :: "r"(&func_test));

  ((void (*)(void))0x80010CB8)();
  ((void (*)(void))0xC0002008)(); // Processor stall indefinitely.
  print("Test");
}

func_test address: 80010C98
Meme!
\end{verbatim}




\chapter{Evaluation} 
\section{Methodology}
\subsection{Benchmarking \& Counting cycles}
From the Risc-V specification, we take a look at the mcycles and minstret
registers
.
\subsection{Synthesis}

\section{Accelerator}
% TODO: Example + study (Evaluation)
\subsection{Fused Multiply Accumulate}

% Cannot exploit pipelined nature of unit.
% Faster than individual FP multiply, then add. 10 cycles vs 14 cycles.

%  10: FSM Start
%  20: Init
%  40: PUT: 00000000 40800000 40800000
%  40: STATE_LOCK
% 140: 0: MulAcc Result: 41800000
% 140: STATE_READY
% 150: PUT: 41800000 40800000 40800000
% 150: STATE_LOCK
% 250: 1: MulAcc Result: 42000000
% 250: STATE_READY
% 260: PUT: 42000000 40800000 40800000
% 260: STATE_LOCK
% 360: 2: MulAcc Result: 42400000
% 360: STATE_READY
% 370: PUT: 42400000 40800000 40800000
% 370: STATE_LOCK
% 470: 3: MulAcc Result: 42800000
% 470: STATE_COMPLETE
% 480: Output: 42800000


\subsection{}

\begin{align*}
  T_{Naive}(N) &= 11+N + 4N \\
  &= 15 + 5N \\
  T_{FMA}(N) &= (10+1)N \\
             &= 11N \\
  T_{TADD}(N) &= max(10+N, 11+2\frac{N}{2} + \frac{N}{4} + ... + 16) \\
             &= 2N+27 
\end{align*}



% TODO: ARM Cortex benchmark

\subsection{MNIST Neural Network: Dense Layers}

\section{Synthesis}
\subsection{Implementation}
\subsection{Xilinx Arty A7-100T}

\chapter{Summary and Conclusions} 


\appendix
\singlespacing

\bibliographystyle{unsrt} 
%\bibliography{dissertation} 

\end{document}
