%% 
%% ACS project dissertation template. 
%% 
%% Currently designed for printing two-sided, but if you prefer to 
%% print single-sided just remove ",twoside,openright" from the 
%% \documentclass[] line below. 
%%
%%
%%   SMH, May 2010. 

\documentclass[a4paper,9pt]{report}
%\documentclass[a4paper,12pt,twoside,openright]{report}


%%
%% EDIT THE BELOW TO CUSTOMIZE
%%

\def\authorname{Khalid Aleem\xspace}
\def\authorcollege{Trinity College\xspace}
\def\authoremail{ka476@cam.ac.uk}
\def\dissertationtitle{A Risc-V based co-processor peripheral to accelerate CNN inference.}
% Maximising throughput for a Risc-V linear algebra co-processor.
\def\wordcount{14,235}


%\usepackage[dvips]{epsfig,graphics} 
\usepackage{epsfig,graphicx,verbatim,parskip,tabularx,setspace,xspace}

\usepackage{booktabs}
\usepackage{amsmath,amssymb}
\usepackage{fancyvrb,listings}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{blue!40!black},
  commentstyle=\itshape\color{purple!40!black},
  stringstyle=\color{green!40!black},
  morekeywords={uint32_t,uint8_t}
}


%% START OF DOCUMENT
\begin{document}


%% FRONTMATTER (TITLE PAGE, DECLARATION, ABSTRACT, ETC) 
\pagestyle{empty}
\singlespacing
\input{titlepage}
\onehalfspacing
\input{declaration}
\singlespacing
\input{abstract}

\pagenumbering{roman}
\setcounter{page}{0}
\pagestyle{plain}
\tableofcontents
\listoffigures
\listoftables

\onehalfspacing


\chapter{Introduction}
\pagenumbering{arabic} 
\setcounter{page}{1} 

% Work on Story
% Embedded Devices
% Common for embedded devices to have their own acclerators
% RiscV - ^ - 


% What are our main contributions:
% Improved upon/got working (FPU) test bench, and
% firmware for rapid prototyping and simulations
% of a Risc-V based CPU



\chapter{Background} 
\section{Risc-V Instruction Set}

\section{Simulating Hardware}
% Risc-V
% Verilator

\section{Synthesis of Hardware}
% Xilinx Vivado
% Symbiflow

\section{ChiselHDL \& SpinalHDL}
\section{Bluespec Verilog}
% Features
% Example code / Comparisons
% Benefits

\chapter{Related Work} 
\section{Open Source Hardware}
% Processors:
% BlueVec
% Rocket RoCC
\section{}
% Google TPU?
% Nvidia GPUs?!

% Bluespec Verilog

\chapter{Design and Implementation}
% Design decisions

% Test bench --- functional
% Floating point unit (mstatus csr)
% RV32imafc - bare metal ELF
% Linker file, bare metal
% Spike, proxy kernel
% Bare Metal LibC - RiscV
% Heap memory!

% Cost of movement...

% Matrix multiplication
% Naive implementation
% Unit duplication NAIVE
% Unit duplication - scheduling
% Copy cost

% endianness & packing

% ZipReduceUnitServer - improvements + bench
% Unit duplication - special memory & wire connections!
%


% RegFile vs Vector#(Reg#()) vs BRAM


\section{SoC Design}
% TODO: image of SoC
% CPU/AXI4 e.t.c.
% Piccolo
% VexRiscV
% Rocket
% SiFive Freedom E310
\subsection{ARM Cortex M0/M3}
\subsection{Freedom E500}
\subsection{VexRiscV}
\subsection{Piccolo}

\subsection{AXI4 Protocol}
% TODO: Background info/filler and origin
\texttt{wstrb}
% TODO: How is memory read/written from

The AXI4 protocol comes with the disadvantage of being able write a maximum of 4
bytes per request. Each request, orchestrated by the CPU, spans multiple clock cycles.
% TODO: To what extent does this 

\section{Testbench Setup}
\subsection{Risc-V Assembly \& Firmware Structure}
\subsubsection{Linker File}
% TODO: Avoiding stack overflow
% TODO: 

\subsection{Floating Point Unit}
\subsubsection{Fixing Piccolo FPU typeerrors}
The latest commit of the Piccolo processor, (), has a type error in the floating
point unit. 

We must enter, FPU.bsv and FBox\_Core.bsv and prefix the RoundMode type with FloatingPoint::RoundMode.

% NOTE: Compile log
% compiling Piccolo/src_Core/CPU/FPU.bsv
% Warning: Unknown position: (S0080)
% 1 warnings were suppressed.
% Error: "Piccolo/src_Core/CPU/FPU.bsv", line 52, column 30: (T0080)
% Type error at the use of the following function:
% mkFloatingPointDivider

% The expected return type of the function:
% g__#(ClientServer::Server#(Tuple3#(FPU::FSingle, FPU::FSingle, ISA_Decls::RoundMode), FPU::FpuR))

% The return type according to the use:
% c__#(ClientServer::Server#(Tuple3#(FloatingPoint::FloatingPoint#(d__, e__),
% FloatingPoint::FloatingPoint#(d__, e__),
% FloatingPoint::RoundMode),
% Tuple2#(FloatingPoint::FloatingPoint#(d__, e__), FloatingPoint::Exception)))


\subsubsection{mstatus CSR}
Once the FPU is successfully compiled, and the processor is compiled with
floating point support, the processor will trap when a floating point
instruction is executed.

% NOTE: Clean code
\texttt{float a = 1.0f;} \\
\texttt{80002276: lui a5, 0x80001}
\texttt{8000227a: flw fa5,424(a5)}
\texttt{8000227e: fsw fa5,-28(s0)}
\texttt{Trap\_Info { epc: 'h8000227a, exc\_code: 'h2, tval: 'h1a87a787 }} \\
\texttt{Trap Exc: ILLEGAL\_INSTRUCTION} \\

% TODO: Citation
This makes sense as per the Risc-V specification, Chapter 3, Section 1.11.
The fs bit on the mstatus CSR must be set in order for floating-point
instructions to be enabled. We can see how this is done in bare-metal C, by
looking at the source code for the Spike Risc-V proxy kernel.

% https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf

\subsection{Test AXI4 Peripheral}
When constructing an accelerator, it is important to work constructively from a minimum
functioning unit.

We make use of the test bench provided by Piccolo as a basis for our
simulations.

We create a simple peripheral, with a region of memory that we can write 4-byte
integers into. When a special execution bit is set, we set a special accelerator
busy bit and unset the execution bit. In a single cycle, as part of the
accelerator, if the busy bit is set, we double the array and unset the busy bit.
This allows the firmware to write an array into the accelerator memory, set the
execution control bit, and stall until the busy bit is unset.

% NOTE: Firmware C code for accelerator
\begin{lstlisting}[language=C,style=customc]
#define TEST_CONTROL_ADDR 0xC0001000UL
#define TEST_DATA_ADDR 0xC0001008UL
#define TEST_RANGE 4
void main() {
  for(int i=0; i<TEST_RANGE; i++) {
    *((uint32_t volatile*)TEST_DATA_ADDR+i) = i;
    uint32_t data = *((uint32_t*)data_addr+i);
    printf("%d: %d\n", i, data);
  }

  println("Set Control Bit..");
  *((uint8_t volatile*)TEST_CONTROL_ADDR) |= 0x1;

  while(*((uint8_t volatile*)TEST_CONTROL_ADDR) & 0x2 == 0) {}
  println("Stalling..");

  println("Stall complete!");
  for(int i=0; i<TEST_RANGE; i++) {
    uint32_t data = *((uint32_t volatile*)TEST_DATA_ADDR+i);
    printf("%d: %d\n", i, data);
  }
}
\end{lstlisting}
% NOTE: Console log
\begin{verbatim}
0: 0
1: 1
2: 2
3: 3
Set Control Bit..
Stalling..
Stall complete!
0: 0
1: 2
2: 4
3: 6
\end{verbatim}

\subsection{AXI4 Alignment/Padding}

This code results in the cpu trapping:
\begin{verbatim}
*((uint32_t\*)0xC0001002) = 1337;
Trap_Info { epc: 'h800022d6, exc_code: 'h6, tval: 'hc0001002 }
TRAP EXC: STORE_AMO_ADDR_MISALIGNED
The exception/trap code corresponds to:
\end{verbatim}

\subsection{Struct Padding}
% TODO: Introduce the need for struct padding/packing
This is of particular importance to consider when we issue a command to the
accelerator. In order to ensure 

\section{Matrix Multiplication Peripheral}
\subsection{Overview}
Mathematically, the result of a matrix multiplication may be expressed
accordingly:
\begin{align*}
  C &= AB \\
  C_{ij} &= \sum_k A_{ik}B_{kj}
\end{align*}

Matrix multiplication may be expressed in a programmatic form accordingly:
\texttt{C[i][j] = sum zipWith (op*) (row A i) (col B j)}

This can be implemented in two possible ways.
We could approach things purely in hardware, issue a command containing the
locations and dimensions of each of the matrices, and expect the hardware to
write an output matrix to our memory.
Alternatively, we may take advantage of the existence of firmware. It is
possible that 

Our peripheral contains a RegFile of internal memory which is memory mapped to
the CPU via an AXI4 bus slave interface.

\begin{table}
  \centering
\begin{tabular}{lll}
  \toprule
  Offset Address Range & Size & Purpose \\
  \midrule
  \texttt{0x0000-0x0020} & 32 Bytes & Status \\
  \texttt{0x0020-0x0040} & 32 Bytes & Control \\
  \texttt{0x0040-0x1000} & $\approx$ 4 KB & Memory \\
  \bottomrule
\end{tabular}
\end{table}

\subsubsection{Status}
The first byte of our status memory is to monitor, and control execution from
the accelerator.
We write our control command/instruction to the control memory bank. We then set out
execute status bit, and the accelerator should run the appropriate command.

\subsubsection{Control}

\subsubsection{Memory}

\subsection{Design Decisions}
\subsubsection{Hybrid/Monolithic}

\subsection{Command Issuing \& Decoding}
% Endianness (BSV)
% Struct padding

\subsection{DP Unit Design} 
BSV contains a FloatingPoint library, which extends the Server module.
We can put a request, and after some number of clock cycles, get a response.

\subsubsection{Fused Multiply-Accumulate}


\subsubsection{Pipelined Multiplication with Addition}
\subsubsection{Pipelined Multiplication \& Pairwise Addition}
% Unit Design: TODO: Include diagram

% Unit: Memory Parallelism
% Unit: Memory Banking:

\subsection{DP Unit Parallelism}
% TODO: Naive. READ/WRITE ports
% \subsection{Why bluespec?}
% \subsection{Bluespec - Polymorphism/Configurable hardware}


% TODO: Evaluation of results: ~10x faster
% TODO: Explanation of results
% 

% TODO: Jesus...
\subsection{Multi-Ported Memory}

% What is a Regfile, What is BlockRam? What is SRAM?
We observe that a RegFile, has a maximum of 5 read ports, and 1 write port.
Typically, BRAM, has 2 read ports, and 1 write port.

% Error: "MultiPortBRAM.bsv", line 18, column 37: (G0002)
% `pmem_mem_0.sub' needs more than 5 ports for the following uses:
% `pmem_mem_0.sub a__h30554' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h31995' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32028' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32061' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32094' at "MultiPortBRAM.bsv", line 18, column 37
% `pmem_mem_0.sub a__h32127' at "MultiPortBRAM.bsv", line 18, column 37

\subsubsection{Memory Striping}

\subsection{Rule conflicts, rapid execution}

% TODO: UNKNOWN TIMINGS?:
% TODO: Cycle count / byte read in IO memory (when bypassing the cache!?)
% TODO: CACHE R/W speed!?

\section{Commmunication Bottleneck}
\subsection{Protocol efficiency/optimisation}
% Analysis of struct packing
% Attribute ((packed))
% uint8_t offset <-- redundant (-3 bytes)
% uint8_t unit <-- push to accelerator

% uintptr_t <-- Make ADDR 16 bits!?, subtract base address (64KB accel memory...) ()
% (-3*2=-6 bytes)
% 0xC0002900 --> 32 bits
% 2900 --> 16 bits
% 1000 (16-bit base address)
% 1900
% 6 bytes ~=? 6 cycles saved
% 2-4 cycles/base address subtraction
% ALIGN: ACCEL @ 16-bit base address boundary
% Therefore 0-cost LE typecast <---> address calculation! (SMART)


\subsection{Command Buffering}
% In firmware
% Stack Instruction Buffering
% In hardware
% Accelerator buffer/program counter. (Internal stack)

\begin{table}
  \centering
  \begin{tabular}{r|rr}
    \toprule
    Units & Peripheral & Processor\\
    \midrule
    0  &     ? & 21500 \\
    1  & 13366 & 13596 \\
    2  &  6817 &  7085 \\
    4  &  3670 &  3954 \\
    8  &  2621 &  2889 \\
    12 &  2666 &  2929 \\
    16 &  2633 &  2916 \\
    \bottomrule
  \end{tabular}
  \caption{Overhead: Buffer cycles: 723. Copy cycles: 4984}
\end{table}


\subsection{Firmware Stalling/Interrupts}

\subsection{Instruction jumping}


\chapter{Evaluation} 
\section{Methodology}
\subsection{Benchmarking \& Counting cycles}
From the Risc-V specification, we take a look at the mcycles and minstret
registers
.
\subsection{Synthesis}

\section{Accelerator}
% TODO: Example + study (Evaluation)
\subsection{Fused Multiply Accumulate}

% Cannot exploit pipelined nature of unit.
% Faster than individual FP multiply, then add. 10 cycles vs 14 cycles.

%  10: FSM Start
%  20: Init
%  40: PUT: 00000000 40800000 40800000
%  40: STATE_LOCK
% 140: 0: MulAcc Result: 41800000
% 140: STATE_READY
% 150: PUT: 41800000 40800000 40800000
% 150: STATE_LOCK
% 250: 1: MulAcc Result: 42000000
% 250: STATE_READY
% 260: PUT: 42000000 40800000 40800000
% 260: STATE_LOCK
% 360: 2: MulAcc Result: 42400000
% 360: STATE_READY
% 370: PUT: 42400000 40800000 40800000
% 370: STATE_LOCK
% 470: 3: MulAcc Result: 42800000
% 470: STATE_COMPLETE
% 480: Output: 42800000


\subsection{}

\begin{align*}
  T_{Naive}(N) &= 11+N + 4N \\
  &= 15 + 5N \\
  T_{FMA}(N) &= (10+1)N \\
             &= 11N \\
  T_{TADD}(N) &= max(10+N, 11+2\frac{N}{2} + \frac{N}{4} + ... + 16) \\
             &= 2N+27 
\end{align*}



% TODO: ARM Cortex benchmark

\subsection{MNIST Neural Network: Dense Layers}

\section{Synthesis}
\subsection{Implementation}
\subsection{Xilinx Arty A7-100T}

\chapter{Summary and Conclusions} 


\appendix
\singlespacing

\bibliographystyle{unsrt} 
%\bibliography{dissertation} 

\end{document}
